# learn
一、内联函数
	

二、引用
	



三、返回引用：
	函数返回值为引用类型：
	函数return 时，return的变量会被销毁，注意return的是引用还是引用的对象。
	1、如果return的是引用的对象，则会有问题
	2、如果return的是引用，则程序正常
	
	例：注意区别于这两个例子
	
	
	
		不要返回指向局部变量或者临时变量的引用
		
四、基类的引用可以指向派生类对象，而无需进行强制类型转换。即函数的参数为基类的引用，实参可以是基类，也可以是派生类！

五、传递数组用指针、传递类用引用、传递结构体用指针或引用、传递基本类型用引用或者指针或者按值传递

六、默认参数
	声明时，默认参数从右向左设置
	
	
	省内存运行速度快的写法（判断字符串长度）:
	
	


七、左值右值及引用
	1、左值：可以取地址的值；如变量
	
	2、右值：不可以取地址的值；如常量
		a = 1; //a为左值，1为右值
		b = 2; //b为左值，2为右值
		a + b; //a+b为右值
	
	3、左值引用（&）：int &a = b;  左值引用（&a）的运算符右侧（b）一定是左值。
	
	4、常引用（const）：
		int &a = 10;  -----> 报错
		const int &a = 10;
		const int &b = (c+d);
		？const 关键字使得常量10、（c+d）赋值给临时变量(发生拷贝的动作)，使得a、b变成对临时变量的引用。同二、3点
		
		注意：常引用只能通过引用读取数据，不能通过引用修改数据
	
		const int &a = b;//左值赋值给常引用，没有临时变量，直接复制
		
	
	5、右值引用（&&）：------->该写法常用于移动语义、构造函数、析构函数
		int &&x = 10;
		int &&y = (a+b);

八、函数重载（函数多态）
	1、函数重载的关键：参数列表——函数特征标（特侦表只关注数目、类型、排列顺序；不关注：变量名、返回值）
		a、可以有同名函数，但特征标需要不同
		
		b、只有一个同名函数时，参数不匹配则进行强制类型转换
		
		c、有多个同名函数时，参数与任何一个同名函数都不匹配则报错！
		
		d、不能共存的同名函数：例：
			double cube(double x);
			double cube(double &x);
			以上两个函数为同一个特征
			如double x参数可以同时匹配以上两个函数
			
		  e、const相关：非const实参赋值给const形参------->可行
					     const实参赋值给非const形参---->不可行
		  
		  f、
			
	
	
			G、以下是同一个函数（同一个特征标）
			
	
	2、函数重载的使用场景
		仅当函数基本上执行相同的任务，但使用不同类型的数据
	
九、函数模板
	背景：当同一个函数需要传不同类型的参数时，可以使用结构体，但是增加开销（我猜的），可以使用函数重载，但是代码较为冗余且容易出错；所以引入函数模板
	例：
	template <typename AnyType>
	void Swap(AnyType &a, AnyType & b)
	{
		AnyType temp;
		temp = a;
		a = b;
		b = temp;
	}
	
	typename 可用 class 代替
	注意：template <typename AnyType>后没有分号；写在函数前；定义与声明时都要写。
		函数模板被多个不同的类型参数调用时，编译时会自动生成多个不同类型参数的函数，与手写多个不同类型参数的函数（函数重载）一样。
	
	1、重载模板:与函数重载类似
	
	2、显示具体化
	    背景:模板类不适用于所有实参类型，如结构体、数组。
	    如:Swap(a,b);#a,b为数组
	         则Swap函数模板中的a=b表达式不成立，a与b均为地址。
	    用显示具体化再次定义Swap:
	    如有结构体job
	    template<> void Swap<job>(job &a, job &b)
	    {
	    
	    }
	    
	    
	
	
	
    3、实例化（函数模板的显式和隐式实例化）
        a.模板函数隐式实例化:传参后被调用时才生成函数的定义。（模板不是函数定义）
           如果有很多地方调用函数模板，则会生成很多个函数定义，效率低且浪费内存空间

        b. 模板函数显式实例化:不管调不调用都生成函数的定义。
               template viod Swap<int>(int, int)
               注意区别于显示具体化的写法，显示具体化也在未调用时生成函数定义
           
            无论多少地方调用函数模板，只在显示实例化时定义一次，效率高且省内存

            场景:编译生成so库时需要用显示实例化

十、函数重载：
	1、调用关系：常规函数调用高于模板函数
			显示具体化优于使用模板隐士具体化
			转换工作量少的优先于转换工作量大的
			
	2、告知编译器调用某个函数模板:如有
	      template <typename T>
	      T learn(T a, Tb)
	        {
	        }
	
	      int learn(int a, int b)
	      {
	      }
	
	        调用:learn<>(3, 4);------->调用的是函数模板
	
	      调用:learn<int>(3.2, 4.5);------>将传入的浮点数参数强制转换为int类型，并且调用的是函数模板。
	
	3、背景
		template <typename T1, typename T2>
		void ft(T1 x, T2 y)
		{
			type? xy = x + y;   //有两个函数模板参数时，无法确定xy的类型（问题）
		}
	
		解决以上问题（C++11）：
			decltype关键字
			如：
				int x;
				decltype(x) y; //y的类型与x一致
				
			template <typename T1, typename T2>
			void ft(T1 x, T2 y)
			{
				decltype(x+y) xy = x + y;   //xy的类型为x+y表达式后的类型
			}
			
		4、问题：
			template <typename T1, typename T2>
			type? ft(T1 x, T2 y) //有两个函数模板参数时，无法确定函数返回值
			{
				return x + y;   
			}
			
			解决：
			template <typename T1, typename T2>
			auto ft(T1 x, T2 y) -> decltype(x + y)    //后置返回类型，即先声明参数，再声明返回类型
			{
				return x + y;   
			}
			
			(正常函数先声明返回值再声明参数)
			
			
![Uploading image.png…]()
